<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simulation | Hyojeong Yu</title>
    <link rel="stylesheet" href="../../style.css" />
</head>

<body>

    <header>
        <nav class="nav-container">
            <div class="nav-inner">

                <div class="logo">
                    <a href="../../index.html">HJ</a>
                </div>

                <ul class="nav-links">
                    <li class="dropdown">
                        <a href="#" data-ko="í”„ë¡œì íŠ¸" data-en="Projects"></a>

                        <ul class="dropdown-menu">
                            <li><a href="rendering.html">Rendering</a></li>
                            <li><a href="simulation.html">Simulation</a></li>
                            <li><a href="engine.html">Engine Systems</a></li>
                            <li><a href="system.html">Systems Engineering</a></li>
                        </ul>
                    </li>
                    <li><a href="../research.html" data-ko="ì—°êµ¬" data-en="Research"></a></li>
                    <li><a href="../news.html" data-ko="ë‰´ìŠ¤" data-en="News"></a></li>
                </ul>

                <div class="lang-switch">
                    <a href="?lang=ko">ğŸ‡°ğŸ‡·</a> |
                    <a href="?lang=en">ğŸ‡ºğŸ‡¸</a>
                </div>

            </div>
        </nav>
    </header>

    <main class="home-container">

        <!-- LEFT PROFILE (indexì™€ ë™ì¼) -->
        <div class="profile-card">

            <img src="../../assets/images/profile.jpg" alt="Profile" class="profile-img" />

            <h1 data-ko="ìœ íš¨ì •" data-en="Hyojeong Yu"></h1>

            <p class="title" data-ko="ì—”ì§„ ë° ì‹œë®¬ë ˆì´ì…˜ í”„ë¡œê·¸ë˜ë¨¸" data-en="Engine & Simulation Programmer">
            </p>

            <div class="links">
                <a href="https://www.linkedin.com/in/hyojeong-yu-5412851a6" target="_blank" rel="noopener noreferrer"
                    data-ko="ë§í¬ë“œì¸" data-en="LinkedIn"></a>

                <a href="https://github.com/hjyu94" target="_blank" rel="noopener noreferrer" data-ko="ê¹ƒí—ˆë¸Œ"
                    data-en="GitHub"></a>

                <a href="mailto:hjeong.you@gmail.com" data-ko="ì´ë©”ì¼" data-en="Email"></a>

                <p data-ko="ğŸ“ ë©œë²„ë¥¸, í˜¸ì£¼" data-en="ğŸ“ Melbourne, Australia"></p>
            </div>

        </div>


        <!-- RIGHT CONTENT -->
        <div class="summary">

            <section class="simulation-projects">
                <h2 data-ko="ì‹œë®¬ë ˆì´ì…˜ í”„ë¡œì íŠ¸" data-en="Simulation Projects"></h2>

                <!-- ODE Solver: Spring-Damper System -->
                <article class="project-item">
                    <h4>ODE Solver for Spring-Damper System (Harmonic Oscillator) <span
                            class="project-date">2023-03-31</span></h4>

                    <div class="video-embed">
                        <iframe src="https://www.youtube.com/embed/_GOiQVUESVg?si=HTd3Bleqvkujw4NL"
                            title="ODE Spring-Damper Simulation"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    </div>



                    <details class="project-details">
                        <summary data-ko="ì„¤ëª… ë³´ê¸°" data-en="View description"></summary>
                        <div class="project-description">
                            <h4>ê³¼ì œ ìš”ì•½</h4>
                            <p>
                                1ì°¨ì› ìŠ¤í”„ë§â€“ëŒí¼(ì¡°í™” ì§„ë™ì) ìš´ë™ì„ ìˆ˜ì¹˜ ì ë¶„ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜. ì—¬ëŸ¬ ODE ì†”ë²„ë¥¼ êµ¬í˜„í•´ ë¹„êµ. ì²œì¥ì— ê³ ì •ëœ ìŠ¤í”„ë§ ëì— ì§ˆëŸ‰ì´ ë§¤ë‹¬ë¦° êµ¬ì¡°, yì¶•ë§Œ
                                ì‚¬ìš©.
                            </p>

                            <h4>ìš´ë™ ë°©ì •ì‹</h4>
                            <p class="formula">a = âˆ’(K<sub>s</sub>/m)(x âˆ’ L<sub>rest</sub>) âˆ’ (K<sub>d</sub>/m)v + g</p>
                            <p>
                                í›… ë²•ì¹™(ìŠ¤í”„ë§ë ¥) + ì„ í˜• ëŒí•‘ + ì¤‘ë ¥. 2ì°¨ ODE: máº = âˆ’K<sub>s</sub>(x âˆ’ L<sub>0</sub>) âˆ’ K<sub>d</sub>áº‹
                                + mg
                            </p>

                            <h4>êµ¬í˜„í•œ ODE ì†”ë²„</h4>
                            <p><strong>Explicit Euler</strong></p>
                            <p class="formula">v<sub>n+1</sub> = v<sub>n</sub> + dtÂ·a<sub>n</sub>, &nbsp;
                                x<sub>n+1</sub> = x<sub>n</sub> + dtÂ·v<sub>n</sub></p>
                            <p>ìœ„ì¹˜ ê°±ì‹ ì— <strong>ì´ì „</strong> ì†ë„ ì‚¬ìš©. dtê°€ í¬ë©´ ë¶ˆì•ˆì •(ì—ë„ˆì§€ ë°œì‚°).</p>

                            <p><strong>Symplectic Euler</strong></p>
                            <p class="formula">v<sub>n+1</sub> = v<sub>n</sub> + dtÂ·a<sub>n</sub>, &nbsp;
                                x<sub>n+1</sub> = x<sub>n</sub> + dtÂ·v<sub>n+1</sub></p>
                            <p>ìœ„ì¹˜ ê°±ì‹ ì— <strong>ìƒˆ</strong> ì†ë„ ì‚¬ìš©. ì—ë„ˆì§€ ë³´ì¡´ íŠ¹ì„±ì´ Explicitë³´ë‹¤ ì¢‹ìŒ.</p>

                            <p><strong>Implicit Euler</strong></p>
                            <p>
                                âˆ‚f/âˆ‚v, âˆ‚f/âˆ‚xë¡œ 1ì°¨ ì„ í˜•í™”í•´ Î”vë¥¼ êµ¬í•œ ë’¤ ê°±ì‹ . í° dtì—ì„œë„ ì•ˆì •ì . ì—ë„ˆì§€ëŠ” ê°ì‡ .
                            </p>

                            <h4>íŒŒë¼ë¯¸í„°</h4>
                            <p>
                                K<sub>s</sub>â†‘ â†’ ì§„ë™ ì£¼ê¸°â†“. K<sub>d</sub>â†‘ â†’ ê³¼ê°ì‡ . Time Stepâ†‘ â†’ Explicitë§Œ ë¶ˆì•ˆì •,
                                Symplectic/ImplicitëŠ” ì•ˆì •.
                            </p>

                            <h4>UI</h4>
                            <p>
                                ImGui: Gravity, K<sub>s</sub>, K<sub>d</sub>, Mass, Time Step, Rest ê¸¸ì´, ODE Solver ì„ íƒ,
                                Restart.
                            </p>

                            <h4>ì‹¤í—˜</h4>
                            <p>
                                dtë¥¼ í‚¤ìš°ë©° ì†”ë²„ë³„ ë™ì‘ ë¹„êµ. Explicit ë°œì‚°, Symplectic/Implicit ì•ˆì •ì„ ì˜ìƒì—ì„œ ì‹œì—°.
                            </p>

                            <p><strong>Tech:</strong> C++, OpenGL, ImGui</p>
                            <p>
                                Code is private (homework assignment). If you need access, please contact me via email.
                            </p>
                        </div>
                    </details>
                </article>

                <!-- HW3: Bead on the Wire -->
                <article class="project-item">
                    <h4>Bead on the Wire (Constraint Force) <span class="project-date">2023-04-12</span></h4>

                    <div class="video-embed">
                        <iframe src="https://www.youtube.com/embed/4j97pvTRo48?si=_jNqP1oamYTR1ff0"
                            title="Bead on the Wire Simulation"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    </div>

                    <details class="project-details">
                        <summary data-ko="ì„¤ëª… ë³´ê¸°" data-en="View description"></summary>
                        <div class="project-description">
                            <h4>ê³¼ì œ ìš”ì•½</h4>
                            <p>
                                ì…ìë¥¼ ì§êµì¢Œí‘œ p=(x,y)ë¡œ ë‘ê³ , ì›ì  ì¤‘ì‹¬ ë‹¨ìœ„ì› ìœ„ì—ë§Œ ì›€ì§ì´ë„ë¡ êµ¬ì†. Lagrange multiplier(Î»)ë¡œ êµ¬ì†ë ¥ì„ ê³„ì‚°í•´ ì‹œë®¬ë ˆì´ì…˜.
                            </p>

                            <h4>1. êµ¬ì† ì¡°ê±´</h4>
                            <p>
                                ë‹¨ìœ„ì›: C(p) = Â½(xÂ² + yÂ² âˆ’ 1) = 0<br>
                                êµ¬ì†ì˜ ê¸°ìš¸ê¸°: âˆ‡C = p (ì›ì â†’ì…ì ë°©í–¥)
                            </p>

                            <h4>2. ì ìš© í˜ (Applied force)</h4>
                            <pre><code>gravity_force = (0, m * g);
damping_force = -k * velocity;
applied_force = gravity_force + damping_force + mouse_force;</code></pre>
                            <p>
                                ì¤‘ë ¥ (0, mg), g=âˆ’9.8, m=1. ëŒí•‘ âˆ’kvëŠ” ì°¸ê³  êµ¬í˜„ìš©(ë¬´ì‹œ ê°€ëŠ¥). ë§ˆìš°ìŠ¤ ì™¸ë ¥ì€ ì•„ë˜ 4ë²ˆì—ì„œ ì„¤ì •.
                            </p>

                            <h4>3. Lagrange multiplier Î»</h4>
                            <p class="formula">Î» = (âˆ’FÂ·p âˆ’ mvÂ·v) / (pÂ·p)</p>
                            <pre><code>lambda -= feedback_alpha * (dot(p,p) - 1) / 2;  // ìœ„ì¹˜ ë³´ì •
lambda -= feedback_beta * dot(p, v);             // ì†ë„ ë³´ì •</code></pre>
                            <p>
                                Baumgarte ì•ˆì •í™”ë¡œ ìˆ˜ì¹˜ ì˜¤ì°¨ë¡œ ì›ì—ì„œ ë²—ì–´ë‚˜ëŠ” ê±¸ ì¤„ì„.
                            </p>

                            <h4>4. êµ¬ì†ë ¥ê³¼ ê°€ì†ë„</h4>
                            <pre><code>constrained_force = lambda * position;
acceleration = (applied_force + constrained_force) / mass;</code></pre>
                            <p>
                                êµ¬ì†ë ¥ = Î»p, a = (F_applied + Î»p) / m
                            </p>

                            <h4>5. ë§ˆìš°ìŠ¤ ì™¸ë ¥ (UI)</h4>
                            <pre><code>deltaPos = current_pos - prev_mouse_pos;
mouse_force = scale * vec3(deltaPos.x, -deltaPos.y, 0);</code></pre>
                            <p>
                                ë§ˆìš°ìŠ¤ ì´ë™ëŸ‰ì— ë¹„ë¡€. yëŠ” í™”ë©´ ì¢Œí‘œë¼ âˆ’deltaPos.yë¡œ ìœ„ë¡œ ë“œë˜ê·¸ = ìœ„ìª½ í˜.
                            </p>

                            <h4>6. ìˆ˜ì¹˜ ì ë¶„ (Symplectic Euler)</h4>
                            <pre><code>next_velocity = velocity + dt * acceleration;
next_position = position + dt * next_velocity;</code></pre>
                            <p>
                                v<sub>n+1</sub> = v<sub>n</sub> + Î”tÂ·a<sub>n</sub>, p<sub>n+1</sub> = p<sub>n</sub> +
                                Î”tÂ·v<sub>n+1</sub>. ì†ë„ ë¨¼ì € ê°±ì‹  í›„ ìƒˆ ì†ë„ë¡œ ìœ„ì¹˜ ê°±ì‹ .
                            </p>

                            <h4>7. ì´ˆê¸° ì¡°ê±´Â·ìƒìˆ˜</h4>
                            <pre><code>mass = 1.f;
position = (0, 1, 0);
velocity = (0, 0, 0);</code></pre>
                            <p>
                                m=1 kg, p(0)=(0,1), v(0)=(0,0), g=âˆ’9.8 (ê³¼ì œ ëª…ì„¸)
                            </p>

                            <p><strong>Tech:</strong> C++, OpenGL, ImGui</p>
                            <p>
                                Code is private (homework assignment). If you need access, please contact me via email.
                            </p>
                        </div>
                    </details>
                </article>

                <!-- HW4: Collision Detection -->
                <article class="project-item">
                    <h4>Collision Detection between Spheres <span class="project-date">2023-04-28</span></h4>

                    <div class="video-embed">
                        <iframe src="https://www.youtube.com/embed/cIExVv_3WhQ?si=f9Uoy2Uaf2R06h03"
                            title="Sphere Collision Detection"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    </div>

                    <details class="project-details">
                        <summary data-ko="ì„¤ëª… ë³´ê¸°" data-en="View description"></summary>
                        <div class="project-description">
                            <h4>ê³¼ì œ ê°œìš”</h4>
                            <p>3D ê³µê°„ì— ì„œë¡œ ë‹¤ë¥¸ ë°˜ì§€ë¦„ì„ ê°€ì§„ Nê°œì˜ êµ¬ê°€ ëœë¤ ìœ„ì¹˜ì— ìˆë‹¤.</p>
                            <ol class="project-ol">
                                <li><strong>Broad Phase Collision Culling</strong> â€” ê° êµ¬ë¥¼ ê°ì‹¸ëŠ” AABBë¥¼ ë‘ê³ , Sweep and
                                    Pruneìœ¼ë¡œ <strong>ê²¹ì¹  ê°€ëŠ¥ì„±ì´ ìˆëŠ”</strong> êµ¬ ìŒì„ ì°¾ëŠ”ë‹¤.</li>
                                <li><strong>Narrow Phase Collision Detection</strong> â€” ì‹¤ì œë¡œ <strong>ê²¹ì¹˜ëŠ”</strong> êµ¬ ìŒì„
                                    ì°¾ê³ , ê·¸ ìŒì— ëŒ€í•´ <strong>ì¹¨íˆ¬ ê¹Šì´(penetration depth)</strong>ë¥¼ ê³„ì‚°í•œë‹¤.</li>
                                <li><strong>ë Œë”ë§</strong> â€” (a) ì ì¬ì  ì¶©ëŒ êµ¬, (b) ì‹¤ì œ ì¶©ëŒ êµ¬, (c) ì¹¨íˆ¬ ê¹Šì´ ë²¡í„°ë¥¼ OpenGLë¡œ ê·¸ë¦°ë‹¤. ì¹¨íˆ¬ ê¹Šì´
                                    ë²¡í„°: <strong>ê°€ì¥ ê¹Šì´ ì¹¨íˆ¬í•œ ì ì—ì„œ ì‹œì‘í•´, í¬ê¸°ëŠ” ì¹¨íˆ¬ ê¹Šì´</strong>ì¸ ë²¡í„°.</li>
                                <li><strong>UI</strong> â€” êµ¬ ê°œìˆ˜ ë³€ê²½, êµ¬ë§ˆë‹¤ ë‹¤ë¥¸ ìƒ‰, flat shading ë˜ëŠ” í…ìŠ¤ì²˜ë¡œ êµ¬ì˜ ë°©í–¥ í‘œí˜„, êµ¬ ì¬ìƒì„±Â·ì¶©ëŒÂ·ì¹¨íˆ¬
                                    ê¹Šì´ ì¬ê³„ì‚°.</li>
                            </ol>

                            <h4>1) Broad Phase: AABB + Sweep and Prune</h4>
                            <p><strong>ê³¼ì œ ìš”êµ¬</strong> â€” ê° êµ¬ë¥¼ ê°ì‹¸ëŠ” AABBë¥¼ ë‘ê³ , Sweep and Pruneìœ¼ë¡œ ì ì¬ì ìœ¼ë¡œ ê²¹ì¹˜ëŠ” êµ¬ ìŒì„ ì°¾ëŠ”ë‹¤.</p>
                            <p><strong>AABB</strong></p>
                            <ul>
                                <li>ê° êµ¬(Sphere)ëŠ” <code>m_AABB</code>ë¥¼ ê°€ì§ (sphere.h)</li>
                                <li>AABBëŠ” <code>m_start_position</code>, <code>m_end_position</code> (ì¶• ì •ë ¬ ë°•ìŠ¤ì˜ ë‘ ê¼­ì§“ì )
                                    (AABB.h)</li>
                                <li>êµ¬ ìƒì„± ì‹œ:
                                    <code>m_AABB = AABB::Create(m_center - vec3(r,r,r), m_center + vec3(r,r,r))</code>
                                    (sphere.cpp Init)
                                </li>
                            </ul>
                            <p><strong>Sweep and Prune</strong></p>
                            <ul>
                                <li><code>Context::SweepAndPrune()</code> (context.cpp 324í–‰~)</li>
                                <li>x, y, zì¶•ë§ˆë‹¤: ê° êµ¬ì˜ AABB start/end ì¢Œí‘œë¥¼ ì´ë²¤íŠ¸ë¡œ ë“±ë¡ â€”
                                    <code>CompareHelper(sphere, sphere->GetAABB()->m_start_position.x, true)</code>,
                                    <code>CompareHelper(sphere, sphere->GetAABB()->m_end_position.x, false)</code> (xì¶•
                                    ì˜ˆì‹œ). <code>CompareHelper::compare</code>ë¡œ ê°’ ê¸°ì¤€ ì •ë ¬ í›„
                                    <code>FindCollidingSpheres(helpers, x_colliding_spheres)</code>ë¡œ í•´ë‹¹ ì¶•ì—ì„œ ê²¹ì¹  ìˆ˜ ìˆëŠ” ìŒ êµ¬í•¨
                                </li>
                                <li>ì„¸ ì¶• ê²°ê³¼ì˜ <strong>êµì§‘í•©</strong>: <code>temp_output = Intersection(x, y)</code>,
                                    <code>m_broad_colliding_spheres = Intersection(temp_output, z)</code> (373â€“374í–‰)
                                </li>
                                <li>ê²°ê³¼: AABBê°€ ê²¹ì¹˜ëŠ” êµ¬ ìŒ <code>m_broad_colliding_spheres</code></li>
                            </ul>
                            <p><strong>FindCollidingSpheres</strong> (416í–‰~) â€” ì •ë ¬ëœ ì´ë²¤íŠ¸ë¥¼ ìˆœíšŒí•˜ë©°, <code>m_is_start</code>ì¼ ë•Œ
                                í˜„ì¬ "ì—´ë¦°" êµ¬ë“¤ê³¼ ëª¨ë‘ ìŒì„ ë§Œë“¤ì–´ ë„£ê³  ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€, <code>m_is_start == false</code>ì¼ ë•Œ í•´ë‹¹ êµ¬ë¥¼ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°.
                            </p>

                            <h4>2) Narrow Phase: ì‹¤ì œ ì¶©ëŒ ìŒ + ì¹¨íˆ¬ ê¹Šì´</h4>
                            <p><strong>ê³¼ì œ ìš”êµ¬</strong> â€” ì‹¤ì œë¡œ ê²¹ì¹˜ëŠ” êµ¬ ìŒì„ ì°¾ê³ , ê·¸ ìŒì— ëŒ€í•´ ì¹¨íˆ¬ ê¹Šì´ë¥¼ ê³„ì‚°í•œë‹¤.</p>
                            <p><strong>ì‹¤ì œ ê²¹ì¹¨ íŒë³„</strong></p>
                            <ul>
                                <li><code>FindActuallyOverlappedSpheres()</code> (context.cpp 384í–‰~). Broad ê²°ê³¼
                                    <code>m_broad_colliding_spheres</code>ë§Œ ìˆœíšŒ
                                </li>
                                <li><code>distance = glm::distance(center1, center2)</code>,
                                    <code>radius_sum = r1 + r2</code>
                                </li>
                                <li><strong>ì¶©ëŒ ì¡°ê±´</strong>: <code>distance &lt; radius_sum</code> (401í–‰). ì¶©ëŒí•œ ìŒì€
                                    <code>m_narrow_colliding_spheres</code>ì— ë„£ìŒ
                                </li>
                            </ul>
                            <p><strong>ì¹¨íˆ¬ ê¹Šì´ ë²¡í„°</strong></p>
                            <ul>
                                <li>ê³¼ì œ: "ê°€ì¥ ê¹Šì´ ì¹¨íˆ¬í•œ ì ì—ì„œ ì‹œì‘í•˜ê³ , í¬ê¸°ëŠ” ì¹¨íˆ¬ ê¹Šì´"ì¸ ë²¡í„°</li>
                                <li><code>ray = normalize(center2 - center1)</code></li>
                                <li>êµ¬1 í‘œë©´(êµ¬2 ìª½): <code>penetrated_point1 = center1 + radius1 * ray</code></li>
                                <li>êµ¬2 í‘œë©´(êµ¬1 ìª½): <code>penetrated_point2 = center2 - radius2 * ray</code></li>
                                <li>ë‘ ì ì„ ì‡ëŠ” ì„ ë¶„ = ì¹¨íˆ¬ ê¹Šì´ ë²¡í„° (ë°©í–¥ p1â†’p2, í¬ê¸° = <code>radius_sum - distance</code>)</li>
                                <li><code>m_lines.push_back(Line::Create(penetrated_point1, penetrated_point2))</code>
                                    (409í–‰)</li>
                                <li>Logì—ì„œ ì¹¨íˆ¬ ê¹Šì´:
                                    <code>e.first->GetRadius() + e.second->GetRadius() - glm::distance(...)</code>
                                    (148í–‰)
                                </li>
                            </ul>

                            <h4>3) ë Œë”ë§ (a)(b)(c)</h4>
                            <p><strong>ê³¼ì œ ìš”êµ¬</strong> â€” (a) ì ì¬ì  ì¶©ëŒ êµ¬, (b) ì‹¤ì œ ì¶©ëŒ êµ¬, (c) ì¹¨íˆ¬ ê¹Šì´ ë²¡í„°ë¥¼ OpenGLë¡œ ê·¸ë¦°ë‹¤.</p>
                            <p><strong>View ëª¨ë“œ</strong></p>
                            <ul>
                                <li><strong>Model View</strong> (VIEW_MODEL): êµ¬ë§Œ ê·¸ë¦¬ë©°, ê° êµ¬ëŠ” ìì‹ ì˜ ìƒ‰ <code>m_color</code>
                                    (sphere.cpp Render)</li>
                                <li><strong>Broad view</strong> (VIEW_BROAD): <code>ComputeCollision()</code> â†’
                                    <code>SweepAndPrune()</code> í›„, <code>m_broad_colliding_spheres</code>ì— í¬í•¨ëœ êµ¬ë§Œ
                                    <code>SetIntersected(true)</code>. ë Œë” ì‹œ <code>m_isIntersected</code>ë©´ ë¹¨ê°•, ì•„ë‹ˆë©´ ì´ˆë¡ â†’
                                    <strong>(a) ì ì¬ì  ì¶©ëŒ êµ¬ ì‹œê°í™”</strong>
                                </li>
                                <li><strong>Narrow view</strong> (VIEW_NARROW):
                                    <code>FindActuallyOverlappedSpheres()</code> í›„,
                                    <code>m_narrow_colliding_spheres</code>ì— í¬í•¨ëœ êµ¬ë§Œ <code>SetIntersected(true)</code> â†’
                                    <strong>(b) ì‹¤ì œ ì¶©ëŒ êµ¬ ì‹œê°í™”</strong>
                                </li>
                                <li><strong>Penetration view</strong> (VIEW_PENETRATION):
                                    <code>m_narrow_colliding_spheres</code>ë¡œ ì¶©ëŒ ìŒÂ·ì¹¨íˆ¬ì  ê³„ì‚° í›„, ì¹¨íˆ¬ì  ë‘ ê°œë¥¼ ì‡ëŠ” ì„ ë§Œ
                                    <code>m_line_program</code>ìœ¼ë¡œ ê·¸ë¦¼ (<code>m_lines</code>, <code>line->Render</code>)
                                    (context.cpp 212â€“226í–‰) â†’ <strong>(c) ì¹¨íˆ¬ ê¹Šì´ ë²¡í„° ì‹œê°í™”</strong>
                                </li>
                            </ul>
                            <p><strong>ìƒ‰ êµ¬ë¶„</strong> â€” Model View: <code>Sphere::Init()</code>ì—ì„œ êµ¬ë§ˆë‹¤
                                <code>m_color</code> ëœë¤. Broad/Narrow: ì¶©ëŒ ì°¸ì—¬ ì—¬ë¶€ì— ë”°ë¼ ë¹¨ê°•/ì´ˆë¡.
                            </p>

                            <p><strong>Tech:</strong> C++, OpenGL, ImGui, GLM</p>
                            <p>Code is private (homework assignment). If you need access, please contact me via email.
                            </p>
                        </div>
                    </details>
                </article>

                <!-- HW5: Rigid Body Dynamics -->
                <article class="project-item">
                    <h4>Rigid Body Dynamics: Part 1 Colliding Contact <span class="project-date">2023-05-12</span></h4>

                    <div class="video-embed">
                        <iframe src="https://www.youtube.com/embed/yjit_sKmPCA?si=vKKp6PwpWExySypV"
                            title="Rigid Body Dynamics Colliding Contact"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    </div>

                    <details class="project-details">
                        <summary data-ko="ì„¤ëª… ë³´ê¸°" data-en="View description"></summary>
                        <div class="project-description">
                            <h4>ê³¼ì œ ìš”êµ¬ì‚¬í•­ ìš”ì•½</h4>
                            <ul>
                                <li>3D ê³µê°„ì— <strong>Nê°œì˜ êµ¬(solid sphere)</strong>ì™€ <strong>ë¬´í•œ ì§ˆëŸ‰ì˜ í‰ë©´(plane)</strong>ì´ ìˆë‹¤.
                                    êµ¬ëŠ” <strong>ëœë¤ ë°˜ì§€ë¦„</strong>, ì§ˆëŸ‰ M.</li>
                                <li><strong>ë°˜ë°œê³„ìˆ˜(coefficient of restitution)</strong>ëŠ” íƒ„ì„±ì— ê°€ê¹ê²Œ (ì˜ˆ: e = 0.9).</li>
                                <li><strong>êµ¬ì˜ ê´€ì„± í…ì„œ</strong>ëŠ” Wikipedia ë“± ì°¸ê³  (solid sphere: I = (2/5)MRÂ²).</li>
                                <li><strong>ê³ ì • íƒ€ì„ìŠ¤í…(fixed time-stepping)</strong>ê³¼ <strong>ì„í„ìŠ¤ ê¸°ë°˜ ë™ì—­í•™(impulse-based
                                        dynamics)</strong>ìœ¼ë¡œ <strong>ì¶©ëŒ ì ‘ì´‰(colliding contact)</strong>ì„ ì‹œë®¬ë ˆì´ì…˜.</li>
                                <li><strong>Part 1 Colliding Contact ê²°ê³¼ í™œìš©</strong>: êµ¬â€“êµ¬ ì¶©ëŒ ê²€ì‚¬. <strong>ì¶”ê°€ë¡œ</strong>
                                    êµ¬â€“í‰ë©´ ì¶©ëŒ ê²€ì‚¬.</li>
                                <li><strong>ì ‘ì´‰ ì‹œê°(time of contact)</strong>ì„ êµ¬í•˜ì§€ ì•ŠìŒ â†’ <strong>ì¹¨íˆ¬
                                        ìƒíƒœ(penetration)</strong>ì—ì„œ ì„í„ìŠ¤ë¥¼ ì ìš©.</li>
                                <li>Baraff ê°•ì˜ ë…¸íŠ¸(notesg.pdf)ì˜ pseudo code, Geometric Toolsì˜ RigidBody ë“± ì°¸ê³  ê°€ëŠ¥.</li>
                                <li><strong>ë Œë”ë§</strong>: texture mapping ë˜ëŠ” flat shadingìœ¼ë¡œ <strong>íšŒì „ ìš´ë™</strong>ì´ ì˜
                                    ë³´ì´ê²Œ. ì†ŒìŠ¤ì½”ë“œ, ì‹¤í–‰íŒŒì¼, readme ì œì¶œ.</li>
                            </ul>

                            <h4>1. ë°ì´í„° êµ¬ì¡°: Rigid Body, Sphere, Plane</h4>
                            <p><strong>RigidBody</strong> (rigidbody.h)</p>
                            <ul>
                                <li><strong>ì„ ìš´ë™</strong>: <code>m_velocity</code>, <code>m_momentum</code>,
                                    <code>m_mass</code>
                                </li>
                                <li><strong>ê°ìš´ë™</strong>: <code>m_angular_vel</code>, <code>m_angular_momentum</code>,
                                    <code>m_inertia</code> (ìŠ¤ì¹¼ë¼ ê´€ì„±)
                                </li>
                                <li><strong>ë°˜ë°œê³„ìˆ˜</strong>: <code>m_coefficient_of_restitution</code> (ê¸°ë³¸ê°’ 0.9)</li>
                                <li><strong>íšŒì „ í‘œí˜„</strong>: <code>m_quaternion</code> (í–¥í›„ í™•ì¥ìš©)</li>
                            </ul>
                            <p><strong>Sphere</strong> (sphere.h, sphere.cpp) â€” RigidBody ìƒì†</p>
                            <ul>
                                <li>ì¤‘ì‹¬ <code>m_center</code>, ë°˜ì§€ë¦„ <code>m_radius</code>, AABB(ì¶©ëŒ ê²€ì‚¬ìš©)</li>
                                <li><strong>Init</strong>: ì¤‘ì‹¬Â·ë°˜ì§€ë¦„Â·ìƒ‰ ëœë¤. ë°˜ì§€ë¦„ <code>getRandomFloat(0.5f, 1.0f)</code></li>
                                <li><strong>ì§ˆëŸ‰</strong>: <code>m_mass = m_radius * getRandomFloat(0.8f, 1.2f)</code>
                                </li>
                                <li><strong>ê´€ì„±</strong>: <code>m_inertia = 0.4f * m_mass * m_radius * m_radius</code> â†’
                                    Solid sphere I = (2/5)MRÂ²ì´ë¯€ë¡œ 0.4 = 2/5 ì‚¬ìš©</li>
                                <li>ì´ˆê¸° ì†ë„Â·ê°ì†ë„ ëœë¤ ë˜ëŠ” 0. <code>m_momentum = m_mass * m_velocity</code>,
                                    <code>m_angular_momentum = m_inertia * m_angular_vel</code>
                                </li>
                            </ul>
                            <p><strong>Plane</strong> (plane.h) â€” RigidBody ìƒì†</p>
                            <ul>
                                <li>ë¬´í•œ ì§ˆëŸ‰. ì†ë„/ì§ˆëŸ‰ ë¯¸ì‚¬ìš©, <strong>ê²½ê³„</strong>ë§Œ ì‚¬ìš©</li>
                                <li><code>m_x</code>, <code>m_z</code>: í‰ë©´ì´ ìœ í•œ ì‚¬ê°í˜•ìœ¼ë¡œ ì·¨ê¸‰ë˜ëŠ” ë²”ìœ„ (êµ¬ê°€ <code>|x| â‰¤ m_x</code>,
                                    <code>|z| â‰¤ m_z</code> ì•ˆì— ìˆì„ ë•Œë§Œ êµ¬â€“í‰ë©´ ì¶©ëŒ ì²˜ë¦¬)
                                </li>
                            </ul>

                            <h4>2. ì¶©ëŒ ê²€ì‚¬</h4>
                            <p><strong>êµ¬â€“í‰ë©´</strong> (context.cpp Update, 84â€“86í–‰)</p>
                            <ul>
                                <li><strong>is_close</strong>: êµ¬ ì¤‘ì‹¬ì´ ë°”ë‹¥ì— ê°€ê¹ë‹¤ â†’
                                    <code>sphere->GetCenter().y - sphere->GetRadius() &lt; epsilon</code> (epsilon =
                                    0.01), ê·¸ë¦¬ê³  <code>|center.x| â‰¤ m_x</code>, <code>|center.z| â‰¤ m_z</code>
                                </li>
                                <li><strong>ì ‘ê·¼ ì¤‘</strong>: <code>v_rel = dot(velocity, (0,1,0)) &lt; 0</code> (ì•„ë˜ë¡œ ë‚´ë ¤ê°€ëŠ”
                                    ì†ë„ ì„±ë¶„)</li>
                                <li>ì ‘ì´‰ ì‹œê°ì„ êµ¬í•˜ì§€ ì•ŠìŒ â†’ ì´ë¯¸ ì¹¨íˆ¬í•œ ìƒíƒœ(ë˜ëŠ” epsilon ì´ë‚´)ì—ì„œ ìœ„ ì¡°ê±´ì´ë©´ ê·¸ í”„ë ˆì„ì—ì„œ ì„í„ìŠ¤ ì ìš©</li>
                            </ul>
                            <p><strong>êµ¬â€“êµ¬</strong></p>
                            <ul>
                                <li>Part 1 Colliding Contact ê²°ê³¼ ì¬ì‚¬ìš©: <code>SweepAndPrune()</code> â†’
                                    <code>FindActuallyOverlappedSpheres()</code>
                                </li>
                                <li><code>m_broad_colliding_spheres</code>, <code>m_narrow_colliding_spheres</code>ë¡œ ì‹¤ì œ
                                    ê²¹ì¹˜ëŠ” êµ¬ ìŒë§Œ ì·¨ê¸‰ (distance &lt; râ‚ + râ‚‚)</li>
                            </ul>

                            <h4>3. Colliding Contact â€” ì„í„ìŠ¤ ì ìš©</h4>
                            <p><strong>êµ¬â€“í‰ë©´</strong> (context.cpp 80â€“104í–‰)</p>
                            <ul>
                                <li><strong>ì ‘ì´‰ì </strong>: ë°”ë‹¥ ìœ„ ì  <code>pa = (center.x, 0, center.z)</code></li>
                                <li><strong>ì ‘ì´‰ì ì—ì„œì˜ ì†ë„</strong>:
                                    <code>padot = velocity + cross(angular_vel, pa - center)</code>
                                </li>
                                <li><strong>ë²•ì„ </strong>: n = (0, 1, 0). ìƒëŒ€ ì ‘ê·¼ ì†ë„: <code>vrel = dot(n, padot)</code></li>
                                <li><strong>ì„í„ìŠ¤ í¬ê¸° j</strong>: ë‹¨ì¼ ê°•ì²´â€“ë¬´í•œ ì§ˆëŸ‰ ë²½ ê³µì‹. <code>ra = pa - center</code></li>
                                <li><strong>ì ìš©</strong>: <code>m_momentum += j*n</code>,
                                    <code>m_velocity = m_momentum/m_mass</code>,
                                    <code>m_angular_momentum += cross(ra, j*n)</code>, <code>m_angular_vel</code> ì¬ê³„ì‚°
                                </li>
                            </ul>
                            <p><strong>êµ¬â€“êµ¬</strong> (context.cpp 107â€“168í–‰)</p>
                            <ul>
                                <li><strong>ì ‘ì´‰ì </strong>: <code>p1 = center1 + r1 * normalize(center2 - center1)</code>,
                                    p2 ëŒ€ì¹­</li>
                                <li><strong>ì ‘ì´‰ì  ì†ë„</strong>: <code>p1dot = v1 + Ï‰1Ã—(p1-center1)</code>,
                                    <code>p2dot = v2 + Ï‰2Ã—(p2-center2)</code>
                                </li>
                                <li><strong>ë²•ì„ </strong>: n1 = normalize(center1 - center2), n2 = -n1</li>
                                <li><strong>ìƒëŒ€ ì ‘ê·¼ ì†ë„</strong>: <code>vrel = dot(n1, p1dot - p2dot)</code>.
                                    <code>vrel &lt; 0</code>ì¼ ë•Œë§Œ ì„í„ìŠ¤ ì ìš©
                                </li>
                                <li><strong>ì„í„ìŠ¤ í¬ê¸° j</strong>: ë‘ ê°•ì²´ ê³µì‹ (ë¶„ëª¨ì— 1/m1 + 1/m2ì™€ ê° êµ¬ì˜ ê´€ì„± í•­ í¬í•¨).
                                    <code>j = -(1+e)*vrel / (ë¶„ëª¨)</code>
                                </li>
                                <li>s1: <code>m_momentum += j*n1</code>,
                                    <code>m_angular_momentum += cross(ra1, j*n1)</code>. s2: n2, ra2ë¡œ ë™ì¼ ì ìš©
                                </li>
                            </ul>

                            <h4>4. ê³ ì • íƒ€ì„ìŠ¤í… ì ë¶„ (move)</h4>
                            <ul>
                                <li><strong>í˜ ì ìš©</strong> (171â€“178í–‰): êµ¬ê°€ ë°”ë‹¥ì— ê°€ê¹ê³  ë¶™ì–´ ìˆì„ ë•Œ(<code>isClose</code>)ëŠ” force =
                                    0 (ì¶”ê°€ ì¹¨íˆ¬ ë°©ì§€). ê·¸ ì™¸ <code>gravity = (0, m_gravity * m_mass, 0)</code> (m_gravity =
                                    -9.8)</li>
                                <li><strong>Sphere::move(force, timestep)</strong> (sphere.cpp 113â€“119í–‰):
                                    <code>m_momentum += timestep * force</code>,
                                    <code>m_velocity = m_momentum / m_mass</code>,
                                    <code>m_center += timestep * m_velocity</code>, ê°ì†ë„Â·ì¿¼í„°ë‹ˆì–¸ ê°±ì‹ 
                                </li>
                                <li>Fixed time-stepping: ë§¤ í”„ë ˆì„ ë™ì¼í•œ <code>m_timestep</code>(0.01)ìœ¼ë¡œ ì¶©ëŒ ì²˜ë¦¬ í›„ í•œ ë²ˆì”© move í˜¸ì¶œ
                                </li>
                            </ul>

                            <h4>5. ë Œë”ë§</h4>
                            <p>êµ¬Â·í‰ë©´ì€ lighting ì…°ì´ë”ì™€ ë©”ì‰¬ë¡œ ê·¸ë¦°ë‹¤. Texture mapping ë˜ëŠ” flat shadingìœ¼ë¡œ êµ¬ì˜ ë°©í–¥/íšŒì „ì´ ë³´ì´ë„ë¡ êµ¬í˜„ (ë©”ì‰¬+ë¼ì´íŠ¸
                                ê¸°ë°˜ ë Œë”ë§).</p>

                            <p><strong>Tech:</strong> C++, OpenGL, ImGui, GLM</p>
                            <p>Code is private (homework assignment). If you need access, please contact me via email.
                            </p>
                        </div>
                    </details>
                </article>

                <!-- HW6: Rigid Body Part 2 Resting Contact -->
                <article class="project-item">
                    <h4>Rigid Body Dynamics: Part 2 Resting Contact <span class="project-date">2023-05-26</span></h4>

                    <div class="video-embed">
                        <iframe src="https://www.youtube.com/embed/v_oHidZP0R0?si=6fqCBfCxZ1xyJ28X"
                            title="Rigid Body Dynamics Resting Contact"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    </div>

                    <details class="project-details">
                        <summary data-ko="ì„¤ëª… ë³´ê¸°" data-en="View description"></summary>
                        <div class="project-description">
                            <h4>ê³¼ì œ ê°œìš”</h4>
                            <p>
                                Part 1 ì— <strong>Resting Contact</strong>ë¥¼ ì¶”ê°€í•œ ê°•ì²´ ë™ì—­í•™. êµ¬ê°€ ë°”ë‹¥Â·êµ¬ë¼ë¦¬ "ë¶™ì–´ ìˆì„
                                ë•Œ"ë„ ì¤‘ë ¥ì„ ë„ì§€ ì•Šê³ , ë§¤ í”„ë ˆì„ <strong>velocity impulse</strong>ë¡œ ì ‘ì´‰ì  ë²•ì„  ì†ë„ë¥¼ ìƒì‡„í•´ ì¹¨íˆ¬ë¥¼ ì¤„ì´ë ¤ëŠ” êµ¬í˜„.
                            </p>

                            <h4>ë‚´ê°€ êµ¬í˜„í•œ ë‚´ìš©</h4>
                            <ul>
                                <li><strong>1) Colliding contact (context.cpp 79â€“166í–‰)</strong><br>
                                    Part 1 ê³¼ ë™ì¼. êµ¬â€“ë°”ë‹¥: <code>is_close</code>ì´ê³  <code>v_rel &lt; -v_epsilon</code>ì¼ ë•Œ ì ‘ì´‰ì 
                                    ì†ë„
                                    <code>padot = v + Ï‰Ã—r</code>, ë²•ì„  <code>n=(0,1,0)</code>,
                                    <code>j = -(1+e)*vrel / (1/m + ê´€ì„±í•­)</code> ì ìš©. êµ¬â€“êµ¬:
                                    <code>FindActuallyOverlappedSpheres()</code>ë¡œ ì¶©ëŒ ìŒ êµ¬í•œ ë’¤,
                                    <code>vrel &lt; -v_epsilon</code>ì¼ ë•Œë§Œ (1+e) í¬í•¨í•œ ì„í„ìŠ¤ë¡œ ë°˜ë°œ.
                                </li>
                                <li><strong>2) Resting contact (168â€“264í–‰)</strong><br>
                                    <strong>ì¶”ê°€í•œ ë¶€ë¶„.</strong> êµ¬â€“ë°”ë‹¥: <code>is_close</code>ì´ê³ 
                                    <code>|v_rel| &lt; v_epsilon</code>ì¼ ë•Œ <code>j = -vrel / (1/m + ê´€ì„±í•­)</code> (ë°˜ë°œê³„ìˆ˜
                                    ì—†ìŒ). êµ¬â€“êµ¬: <code>m_narrow_colliding_spheres</code> ìŒì— ëŒ€í•´
                                    <code>|vrel| &lt; v_epsilon</code>ì¼ ë•Œ ê°™ì€ ì‹ìœ¼ë¡œ <code>j = -vrel / (ë¶„ëª¨)</code> ì ìš©. ì ‘ì´‰ì ì—ì„œ
                                    ë‚¨ì€ ë²•ì„  ì†ë„ë¥¼ impulseë¡œ ìƒì‡„í•˜ëŠ” ì˜ë„.
                                </li>
                                <li><strong>3) Move (266â€“272í–‰)</strong><br>
                                    ëª¨ë“  êµ¬ì— <strong>í•­ìƒ ì¤‘ë ¥</strong> ì ìš©: <code>sphere->m_force = gravity</code>,
                                    <code>sphere->move(m_timestep)</code>. ë°”ë‹¥ì— ë¶™ì–´ ìˆì–´ë„ forceë¥¼ 0ìœ¼ë¡œ ë‘ì§€ ì•ŠìŒ.
                                </li>
                                <li><strong>ìƒìˆ˜</strong>: <code>distance_epsilon = 0.01</code> (ì ‘ì´‰ íŒì • ê±°ë¦¬),
                                    <code>v_epsilon = 0.6</code> (colliding: <code>v_rel &lt; -v_epsilon</code>ë§Œ ë°˜ë°œ,
                                    resting: <code>|v_rel| &lt; v_epsilon</code>ì¼ ë•Œ ì§€ì§€ ì„í„ìŠ¤).
                                </li>
                            </ul>

                            <h4>Part 1 ê³¼ì˜ ì°¨ì´</h4>
                            <table class="project-table">
                                <thead>
                                    <tr>
                                        <th>êµ¬ë¶„</th>
                                        <th>Part 1</th>
                                        <th>Part 2</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Colliding (íŠ•ê¹€)</td>
                                        <td>êµ¬â€“ë°”ë‹¥Â·êµ¬â€“êµ¬, ì ‘ê·¼ ì‹œ (1+e) ì„í„ìŠ¤</td>
                                        <td>ë™ì¼. <code>v_rel &lt; -v_epsilon</code>ì¼ ë•Œë§Œ ì ìš©</td>
                                    </tr>
                                    <tr>
                                        <td>Resting (ë¶™ì–´ ìˆì„ ë•Œ)</td>
                                        <td>ì—†ìŒ</td>
                                        <td><strong>ì¶”ê°€.</strong> <code>|v_rel| &lt; v_epsilon</code>ì¼ ë•Œ
                                            <code>j = -vrel/â€¦</code> ë¡œ ë²•ì„  ì†ë„ ìƒì‡„
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>Move ì‹œ ì¤‘ë ¥</td>
                                        <td>ë°”ë‹¥ì— ê°€ê¹Œìš°ë©´ <code>force = 0</code></td>
                                        <td>í•­ìƒ <code>m_force = gravity</code>, ì¤‘ë ¥ ìœ ì§€</td>
                                    </tr>
                                </tbody>
                            </table>

                            <h4>êµ¬í˜„ì˜ ë²”ìœ„ì™€ í•œê³„</h4>
                            <p>
                                Resting contactëŠ” "ì ‘ì´‰ì ì— ë‚¨ì€ ë²•ì„  ì†ë„(normal velocity)ë¥¼ ë§¤ í”„ë ˆì„ velocity impulse(<em>j = âˆ’v_rel
                                    / â€¦</em>)ë¡œ ìƒì‡„í•œë‹¤"ëŠ” ì‹ìœ¼ë¡œ ì„¤ê³„í–ˆê³ , ê·¸ì— ë§ì¶° êµ¬â€“ë°”ë‹¥Â·êµ¬â€“êµ¬ ëª¨ë‘ ì ìš©í•´ ë‘ì—ˆë‹¤. ë°˜ëŒ€ë¡œ, ì‰¬ê³  ìˆì„ ë•Œë„ ì¹¨íˆ¬ê°€ ëˆ„ì ë˜ë©´ ì ‘ì´‰ì ì—
                                ì‘ì€ ë²•ì„  ì†ë„ê°€ ë‚¨ì•„ ìˆë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ, ì´ê±¸ ë” ê°•í•˜ê²Œ ìƒì‡„í•˜ê±°ë‚˜ ìœ„ì¹˜ ë³´ì •ì„ ë„£ëŠ” ìª½ì´ ë‹¤ìŒ ë‹¨ê³„ê°€ ëœë‹¤.
                            </p>
                            <p>
                                Impulseë§Œìœ¼ë¡œëŠ” í‰ë©´ ì¹¨íˆ¬ë¥¼ ì™„ì „íˆ ë§‰ê¸° ì–´ë µë‹¤ëŠ” ì ì€ ê°•ì²´ ë™ì—­í•™ ìª½ì—ì„œë„ í”íˆ ë‹¤ë£¨ëŠ” ì´ìŠˆì´ê³ , LCPÂ·stabilization(ìœ„ì¹˜/ì†ë„ ë³´ì •)ì„
                                ë„ì…í•˜ë©´ ë” ì•ˆì •ì ì¸ restingì´ ê°€ëŠ¥í•˜ë‹¤. ì´ë²ˆ êµ¬í˜„ì€ "ê³ ì • íƒ€ì„ìŠ¤í… + impulse ê¸°ë°˜" ë²”ìœ„ ì•ˆì—ì„œ resting contactë¥¼ ë„£ì–´ ë³¸
                                ê²ƒì´ê³ , í•œê³„ë¥¼ ì¸ì§€í•œ ìƒíƒœì—ì„œ stabilizationì€ ë³„ë„ ë‹¨ê³„ë¡œ ë‘ì—ˆë‹¤.
                            </p>

                            <p><strong>Tech:</strong> C++, OpenGL, ImGui, GLM</p>
                            <p>Code is private (homework assignment). If you need access, please contact me via email.
                            </p>
                        </div>
                    </details>
                </article>

            </section>

        </div>

    </main>


    <script src="../../assets/js/lang.js"></script>
</body>

</html>